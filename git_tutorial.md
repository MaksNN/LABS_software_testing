# Инструкция по работе с Git
## Подготовка рабочего места
### Для работы с Git в первую очередь его необходимо установить и настроить. Для начала введем в cmd-консоль команду:
#### git version (показать версию git)
### Если Git уже установлен, данная команда выведет его текущую версию. В противном случае необходимо установить Git.
### Сделать это можно по ссылке:
#### https://git-scm.com/download
### Итак, Git установлен, теперь нужно его настроить. У Git довольно много опций, но мы настроим самые важные: наше имя пользователя и адрес электронной почты. Откроем терминал и запустим команды:
#### git config (увидеть текущие настройки параметров Git)
#### git config --global user.name (задать имя пользователя)
#### git config --global user.email (задать почту пользователя)
### Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.
### Также можно клонировать уже существующий удаленный репозиторий командой:
#### git clone <url> (клонировать репозиторий)
## Инициализация репозитория
### После настройки Git необходимо инициализировать свой локальный репозиторий. Для этого переходим в нужное место в каталоге файлов с помощью команды:
#### cd <адрес>
### После этого инициализируем репозиторий командой:
#### git init (инициализировать репозиторий)
## Первый коммит
### Теперь для примера добавим в наш репозиторий текстовый файл test.txt. Для этого вначале необходимо добавить его в область подготовленных файлов с помощью команды:
#### git add test.txt | <имя_файла> (подготовить файл перед коммитом)
### Если нам необходимо добавить все файлы из каталога, используем команду:
#### git add . (подготовить все файлы в каталоге перед коммитом)
### Теперь, когда все файлы подготовлены, необходимо создать коммит (т.е. слепок нашего текущего сотояния файлов) командой:
#### git commit -m "Наш первый коммит" | <имя_коммита> (закоммитить файл)
### В имени коммита нужно добавить информацию о текущей состоянии файлов (например, краткое описание изменений в них)
### Чтобы автоматически проиндексировать и закоммитить файл, используем команду:
#### git commit -a -m <commit_name> (проиндексировать и закоммитить файл)
### Чтобы изменить сообщение последнего коммита, используем команду:
#### git commit --amend -m <new_commit_name> (изменить имя последнего коммита)
### Чтобы автоматически проиндексировать и закоммитить файл, используем команду:
### Чтобы просмотреть статус файлов, используем команду:
#### git status (проверка содержимого коммита)
### При использовании команды git status мы можем просмотреть, на какой ветке мы сейчас находимся, а также, какой статус имеет каждый файл в репозитории:
##### Untracked files - файлы, не отслеживаемые Git
##### Changes to be committed - измененные файлы, находящиеся в области подготовленных файлов
##### Changes not staged for commit - измененные файлы, не находящиеся в области подготовленных файлов
## Ветки в Git
### Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе.
### Создадим новую ветку командой:
#### git branch test_branch | <имя_ветки> (создать новую ветку, но не переключаться на нее)
### Теперь переключимся на нее командой:
#### git checkout test_branch | <имя_ветки> (переключиться на ветку)
### Если мы хотим создать ветку и сразу переключиться на нее, используем команду:
#### git checkout -b test_branch | <имя_ветки> (создать ветку и сразу переключиться на нее)
### Проверить, в какой ветке мы сейчас находимся можно с помощью команды:
#### git status
### Добавим в наш файл test.txt пару новых строк и закоммитим его, после чего, если мы хотим добавить текущие изменения в основную ветку main, необходимо перейти в ветку main командой:
#### git checkout main
### Затем нужно провести слияние веток main и test_branch. Для этого воспользуемся командой:
#### git merge test_branch (внести изменения ветки test_branch в текущую ветку)
### Теперь наши изменения файла test.txt из ветки test_branch добавлены в основную ветку.
## История коммитов и работа с коммитами
### Если мы хотим просмотреть историю коммитов в репозитории в обратном к хронологическому порядке, используем команду:
#### git log (просмотреть историю коммитов в общем виде)
### Команда git log выводит следующую информацию: контрольную сумму коммита, имя и электронную почту автора, дату создания коммита, сообщение коммита, а также список изменений в нем.
### Если мы хотим увидеть историю коммитов в сокращенном виде, используем команду:
#### git log --stat (просмотреть историю коммитов в упрощенном виде)
### Команда git log --stat выводит такую же информацию, как и git log, но изменения в коммитах представлены в сокращенном виде.
### Если мы хотим увидеть историю о каждом коммите в виде одной строки, используем команду:
#### git log --oneline (просмотреть историю коммитов с выводом в одну строку)
### Команда git log --oneline выводит информацию: контрольную сумму коммита, сообщение коммита.
### Если мы хотим увидеть историю коммитов в виде графа, используем команду:
#### git log --graph (просмотреть историю коммитов с выводом в виде графа)
### Команда git log --graph выводит в виде графа следующую информацию: контрольную сумму коммита, имя и электронную почту автора, дату создания коммита, сообщение коммита.
### Можно просматривать список изменений, внесённых в репозиторий, используя команду:
#### git diff (просмотр списка последних непроиндексированных изменений)
### Эта команда сравнивает содержимое вашего рабочего каталога с ещё не проиндексированными изменениями.
### Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить git diff --staged. Эта команда сравнивает ваши проиндексированные изменения с последним коммитом:
#### git diff --staged (просмотр списка последних проиндексированных изменений)
#### q (выход из git diff)
### Чтобы просмотреть разницу между двумя коммитами, используем команду:
#### git diff <имя_первого_коммита> <имя_второго_коммита>
## Работа с удаленным репозиторием
### Если мы хотим перенести изменения из локального репозитория в удаленный, необходимо сперва добавить удалённый репозиторий и присвоить ему имя. Для этого используем команду:
#### git remote add <название_репозитория> <url-адрес> (добавить новый удаленный репозиторий и назвать его)
### Чтобы перенести изменения из локального репозитория в удаленный, используем команду:
#### git push -u -f <remote-name> <branch-name> (отправить изменения в удалённый репозиторий <remote-name> на ветку <branch-name>)
### Теперь мы можем работать с удаленным репозиторием.
# Возможные варианты решений при конфликте коммитов
## Git прерывает работу в самом начале слияния
### Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд git stash, git checkout, git commit или git reset.
## Git прерывает работу во время слияния
### Сбой в процессе слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. В этом случае нам нужно изменить конфликтующие файлы вручную.
#
# Домашнее задание №1
## Написать команду, которая автоматически индексирует и коммитит файл:
### git commit -a -m <commit_name>
#
# Домашнее задание №2
## Написать команду, которая позволяет изменить последний коммит:
### git commit --amend | --amend -m <new_commit_name>
#
# Домашнее задание №3
## Описать возможные варианты решений при конфликте коммитов
### Git прерывает работу в самом начале слияния
#### Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд git stash, git checkout, git commit или git reset.
### Git прерывает работу во время слияния
#### Сбой в процессе слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. В этом случае нам нужно изменить конфликтующие файлы вручную.